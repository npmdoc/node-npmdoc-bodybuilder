<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/danpaz/bodybuilder#readme"

    >bodybuilder (v2.1.0)</a>
</h1>
<h4>An elasticsearch query body builder.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder">module bodybuilder</a><ol>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>aggregation_builder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>bool_query</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>filter_builder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>query_builder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.aggregation_builder">module bodybuilder.aggregation_builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.aggregation_builder.default">
            function <span class="apidocSignatureSpan">bodybuilder.aggregation_builder.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.bool_query">module bodybuilder.bool_query</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.bool_query.default">
            function <span class="apidocSignatureSpan">bodybuilder.bool_query.</span>default
            <span class="apidocSignatureSpan">(condition, query)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.filter_builder">module bodybuilder.filter_builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.filter_builder.default">
            function <span class="apidocSignatureSpan">bodybuilder.filter_builder.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.query_builder">module bodybuilder.query_builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.query_builder.default">
            function <span class="apidocSignatureSpan">bodybuilder.query_builder.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.utils">module bodybuilder.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.utils.boolMerge">
            function <span class="apidocSignatureSpan">bodybuilder.utils.</span>boolMerge
            <span class="apidocSignatureSpan">(newObj, currentObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.utils.buildClause">
            function <span class="apidocSignatureSpan">bodybuilder.utils.</span>buildClause
            <span class="apidocSignatureSpan">(field, value, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.utils.mergeConcat">
            function <span class="apidocSignatureSpan">bodybuilder.utils.</span>mergeConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.utils.sortMerge">
            function <span class="apidocSignatureSpan">bodybuilder.utils.</span>sortMerge
            <span class="apidocSignatureSpan">(current, field, value)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder" id="apidoc.module.bodybuilder">module bodybuilder</a></h1>











</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.aggregation_builder" id="apidoc.module.bodybuilder.aggregation_builder">module bodybuilder.aggregation_builder</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.aggregation_builder.default" id="apidoc.element.bodybuilder.aggregation_builder.default">
        function <span class="apidocSignatureSpan">bodybuilder.aggregation_builder.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function aggregationBuilder() {
  var aggregations = {};

  function makeAggregation(type, field) {
    for (var _len = arguments.length, args = Array(_len &#x3e; 2 ? _len - 2 : 0), _key = 2; _key &#x3c; _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var aggName = (0, _find2.default)(args, _isString2.default) || &#x27;agg_&#x27; + type + &#x27;_&#x27; + field;
    var opts = (0, _find2.default)(args, _isPlainObject2.default);
    var nested = (0, _find2.default)(args, _isFunction2.default);
    var nestedClause = {};

    if ((0, _isFunction2.default)(nested)) {
      var nestedResult = nested(Object.assign({}, aggregationBuilder(), (0, _filterBuilder2.default)()));
      if (nestedResult.hasFilter()) {
        nestedClause.filter = nestedResult.getFilter();
      }
      if (nestedResult.hasAggregations()) {
        nestedClause.aggs = nestedResult.getAggregations();
      }
    }

    var innerClause = Object.assign({}, _defineProperty({}, type, (0, _utils.buildClause)(field, null, opts)), nestedClause);

    Object.assign(aggregations, _defineProperty({}, aggName, innerClause));
  }

  return {
<span class="apidocCodeCommentSpan">    /**
     * Add an aggregation clause to the query body.
     *
     * @param  {string|Object} type      Name of the aggregation type, such as
     *                                   `&#x27;sum&#x27;` or `&#x27;terms&#x27;`.
     * @param  {string}        field     Name of the field to aggregate over.
     * @param  {Object}        [options] (optional) Additional options to
     *                                   include in the aggregation.
     * @param  {string}        [name]    (optional) A custom name for the
     *                                   aggregation, defaults to
     *                                   `agg_&#x3c;type&#x3e;_&#x3c;field&#x3e;`.
     * @param  {Function}      [nest]    (optional) A function used to define
     *                                   sub-aggregations as children. This
     *                                   _must_ be the last argument.
     *
     * @return {bodybuilder} Builder.
     *
     * @example
     * bodybuilder()
     *   .aggregation(&#x27;max&#x27;, &#x27;price&#x27;)
     *   .build()
     *
     * bodybuilder()
     *   .aggregation(&#x27;percentiles&#x27;, &#x27;load_time&#x27;, {
     *     percents: [95, 99, 99.9]
     *   })
     *   .build()
     *
     * bodybuilder()
     *   .aggregation(&#x27;date_range&#x27;, &#x27;date&#x27;, {
     *     format: &#x27;MM-yyy&#x27;,
     *     ranges: [{ to: &#x27;now-10M/M&#x27; }, { from: &#x27;now-10M/M&#x27; }]
     *   })
     *   .build()
     *
     * bodybuilder()
     *   .aggregation(&#x27;diversified_sampler&#x27;, &#x27;user.id&#x27;, { shard_size: 200 }, (a) =&#x3e; {
     *     return a.aggregation(&#x27;significant_terms&#x27;, &#x27;text&#x27;, &#x27;keywords&#x27;)
     *   })
     *   .build()
     */
</span>    aggregation: function aggregation() {
      makeAggregation.apply(undefined, arguments);
      return this;
    },


    /**
     * Alias for `aggregation`.
     *
     * @return {bodybuilder} Builder.
     */
    agg: function agg() {
      return this.aggregation.apply(this, arguments);
    },
    getAggregations: function getAggregations() {
      return aggregations;
    },
    hasAggregations: function hasAggregations() {
      return !!(0, _size2.default)(aggregations);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.bool_query" id="apidoc.module.bodybuilder.bool_query">module bodybuilder.bool_query</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.bool_query.default" id="apidoc.element.bodybuilder.bool_query.default">
        function <span class="apidocSignatureSpan">bodybuilder.bool_query.</span>default
        <span class="apidocSignatureSpan">(condition, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function boolQuery(condition, query) {
  var cond = CONDITIONS_MAP[condition];
  return {
    bool: _defineProperty({}, cond, [query])
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.filter_builder" id="apidoc.module.bodybuilder.filter_builder">module bodybuilder.filter_builder</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.filter_builder.default" id="apidoc.element.bodybuilder.filter_builder.default">
        function <span class="apidocSignatureSpan">bodybuilder.filter_builder.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterBuilder() {
  var filter = {};

  function addMinimumShouldMatch(str) {
    var shouldClause = (0, _get2.default)(filter, &#x27;bool.should&#x27;);
    if (shouldClause &#x26;&#x26; shouldClause.length &#x3e; 1) {
      filter.bool[&#x27;minimum_should_match&#x27;] = str;
    }
  }

  function makeFilter(boolType, filterType) {
    var nested = {};

    for (var _len = arguments.length, args = Array(_len &#x3e; 2 ? _len - 2 : 0), _key = 2; _key &#x3c; _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if ((0, _isFunction2.default)((0, _last2.default)(args))) {
      var nestedCallback = args.pop();
      var nestedResult = nestedCallback(Object.assign({}, (0, _queryBuilder2.default)(), filterBuilder(), (0, _aggregationBuilder2
.default)()));
      if (nestedResult.hasQuery()) {
        nested.query = nestedResult.getQuery();
      }
      if (nestedResult.hasFilter()) {
        nested.filter = nestedResult.getFilter();
      }
      if (nestedResult.hasAggregations()) {
        nested.aggs = nestedResult.getAggregations();
      }
    }

    filter = (0, _utils.boolMerge)(_defineProperty({}, filterType, Object.assign(_utils.buildClause.apply(undefined, args), nested
)), filter, boolType);
  }

  return {
<span class="apidocCodeCommentSpan">    /**
     * Add a filter clause to the query body.
     *
     * @param  {string}        type    Filter type.
     * @param  {string|Object} field   Field to filter or complete filter
     *                                 clause.
     * @param  {string|Object} value   Filter term or inner clause.
     * @param  {Object}        options (optional) Additional options for the
     *                                 filter clause.
     * @param  {Function}      [nest]  (optional) A function used to define
     *                                 sub-filters as children. This _must_ be
     *                                 the last argument.
     *
     * @return {bodybuilder} Builder.
     *
     * @example
     * bodybuilder()
     *   .filter(&#x27;term&#x27;, &#x27;user&#x27;, &#x27;kimchy&#x27;)
     *   .build()
     */
</span>    filter: function filter() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 &#x3c; _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      makeFilter.apply(undefined, [&#x27;and&#x27;].concat(args));
      return this;
    },


    /**
     * Alias for `filter`.
     *
     * @return {bodybuilder} Builder.
     */
    andFilter: function andFilter() {
      return this.filter.apply(this, arguments);
    },


    /**
     * Alias for `filter`.
     *
     * @return {bodybuilder} Builder.
     */
    addFilter: function addFilter() {
      return this.filter.apply(this, arguments);
    },


    /**
     * Add a &#x22;should&#x22; filter to the query body.
     *
     * Same arguments as `filter`.
     *
     * @return {bodybuilder} Builder.
     */
    orFilter: function orFilter() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 &#x3c; _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      makeFilter.apply(undefined, [&#x27;or&#x27;].concat(args));
      return this;
    },


    /**
     * Add a &#x22;must_not&#x22; filter to the query body.
     *
     * Same arguments as `filter`.
     *
     * @return {bodybuilder} Builder.
     */
    notFilter: function notFilter() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 &#x3c; _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      makeFilter.apply(undefined, [&#x27;not&#x27;].concat(args));
      return this;
    },


    /**
     * Set the `minimum_should_match` property on a bool filter with more than
     * one `should` clause.
     *
     * @param  {any} param  minimum_should_match parameter. For possible values
     *                      see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-minimum-should-match.html
     * @return {bodybuilder} Builder.
     */
    filterMinimumShouldMatch: function filterMinimumShouldMatch(param) {
      addMinimumShouldMatch(param);
      return this;
    },
    getFilter: function getFilter() {
      return filter;
    },
    hasFilter: function h ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.query_builder" id="apidoc.module.bodybuilder.query_builder">module bodybuilder.query_builder</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.query_builder.default" id="apidoc.element.bodybuilder.query_builder.default">
        function <span class="apidocSignatureSpan">bodybuilder.query_builder.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queryBuilder() {
  var query = {};

  function addMinimumShouldMatch(str) {
    var shouldClause = (0, _get2.default)(query, &#x27;bool.should&#x27;);
    if (shouldClause &#x26;&#x26; shouldClause.length &#x3e; 1) {
      query.bool[&#x27;minimum_should_match&#x27;] = str;
    }
  }

  function makeQuery(boolType, queryType) {
    var nested = {};

    for (var _len = arguments.length, args = Array(_len &#x3e; 2 ? _len - 2 : 0), _key = 2; _key &#x3c; _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if ((0, _isFunction2.default)((0, _last2.default)(args))) {
      var nestedCallback = args.pop();
      var nestedResult = nestedCallback(Object.assign({}, queryBuilder(), (0, _filterBuilder2.default)()));
      if (nestedResult.hasQuery()) {
        nested.query = nestedResult.getQuery();
      }
      if (nestedResult.hasFilter()) {
        nested.filter = nestedResult.getFilter();
      }
    }

    query = (0, _utils.boolMerge)(_defineProperty({}, queryType, Object.assign(_utils.buildClause.apply(undefined, args), nested
)), query, boolType);
  }

  return {
<span class="apidocCodeCommentSpan">    /**
     * Add a query clause to the query body.
     *
     * @param  {string}        type    Query type.
     * @param  {string|Object} field   Field to query or complete query clause.
     * @param  {string|Object} value   Query term or inner clause.
     * @param  {Object}        options (optional) Additional options for the
     *                                 query clause.
     * @param  {Function}      [nest]  (optional) A function used to define
     *                                 sub-filters as children. This _must_ be
     *                                 the last argument.
     *
     * @return {bodybuilder} Builder.
     *
     * @example
     * bodybuilder()
     *   .query(&#x27;match_all&#x27;)
     *   .build()
     *
     * bodybuilder()
     *   .query(&#x27;match_all&#x27;, { boost: 1.2 })
     *   .build()
     *
     * bodybuilder()
     *   .query(&#x27;match&#x27;, &#x27;message&#x27;, &#x27;this is a test&#x27;)
     *   .build()
     *
     * bodybuilder()
     *   .query(&#x27;terms&#x27;, &#x27;user&#x27;, [&#x27;kimchy&#x27;, &#x27;elastic&#x27;])
     *   .build()
     *
     * bodybuilder()
     *   .query(&#x27;nested&#x27;, { path: &#x27;obj1&#x27;, score_mode: &#x27;avg&#x27; }, (q) =&#x3e; {
     *     return q
     *       .query(&#x27;match&#x27;, &#x27;obj1.name&#x27;, &#x27;blue&#x27;)
     *       .query(&#x27;range&#x27;, &#x27;obj1.count&#x27;, {gt: 5})
     *   })
     *   .build()
     */
</span>    query: function query() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 &#x3c; _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      makeQuery.apply(undefined, [&#x27;and&#x27;].concat(args));
      return this;
    },


    /**
     * Alias for `query`.
     *
     * @return {bodybuilder} Builder.
     */
    andQuery: function andQuery() {
      return this.query.apply(this, arguments);
    },


    /**
     * Alias for `query`.
     *
     * @return {bodybuilder} Builder.
     */
    addQuery: function addQuery() {
      return this.query.apply(this, arguments);
    },


    /**
     * Add a &#x22;should&#x22; query to the query body.
     *
     * Same arguments as `query`.
     *
     * @return {bodybuilder} Builder.
     */
    orQuery: function orQuery() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 &#x3c; _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      makeQuery.apply(undefined, [&#x27;or&#x27;].concat(args));
      return this;
    },


    /**
     * Add a &#x22;must_not&#x22; query to the query body.
     *
     * Same arguments as `query`.
     *
     * @return {bodybuilder} Builder.
     */
    notQuery: function notQuery() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 &#x3c; _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      makeQuery.apply(undefined, [&#x27;not&#x27;].concat(args));
      return this;
    },


    /**
     * Set the `minimum_should_match` property on a bool query with more than
     * one `should` clause.
     *
     * @param  {any} param  minimum_should_match parameter. For possible values
     *                      see https://www.elastic.co/guide/en/elasticsearch/reference/curre ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.utils" id="apidoc.module.bodybuilder.utils">module bodybuilder.utils</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.utils.boolMerge" id="apidoc.element.bodybuilder.utils.boolMerge">
        function <span class="apidocSignatureSpan">bodybuilder.utils.</span>boolMerge
        <span class="apidocSignatureSpan">(newObj, currentObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function boolMerge(newObj, currentObj) {
  var boolType = arguments.length &#x3e; 2 &#x26;&#x26; arguments[2] !== undefined ? arguments[2] : &#x27;and&#x27;;

  var boolCurrent = void 0;
  var boolNew = void 0;

  // Only one, no need for bool.
  if ((0, _isEmpty2.default)(currentObj)) {
    // Allow starting with &#x27;or&#x27; and &#x27;not&#x27; queries.
    if (boolType !== &#x27;and&#x27;) {
      return (0, _boolQuery2.default)(boolType, newObj);
    }
    return newObj;
  }

  // Make bools out of the new and existing filters.
  boolCurrent = currentObj.bool ? currentObj : (0, _boolQuery2.default)(&#x27;must&#x27;, currentObj);
  boolNew = newObj.bool ? newObj : (0, _boolQuery2.default)(boolType, newObj);

  return mergeConcat({}, boolCurrent, boolNew);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bodybuilder.utils.buildClause" id="apidoc.element.bodybuilder.utils.buildClause">
        function <span class="apidocSignatureSpan">bodybuilder.utils.</span>buildClause
        <span class="apidocSignatureSpan">(field, value, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildClause(field, value, opts) {
  var hasField = !(0, _isNil2.default)(field);
  var hasValue = !(0, _isNil2.default)(value);
  var mainClause = {};

  if (hasValue) {
    mainClause = _defineProperty({}, field, value);
  } else if ((0, _isObject2.default)(field)) {
    mainClause = field;
  } else if (hasField) {
    mainClause = { field: field };
  }

  return Object.assign({}, mainClause, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bodybuilder.utils.mergeConcat" id="apidoc.element.bodybuilder.utils.mergeConcat">
        function <span class="apidocSignatureSpan">bodybuilder.utils.</span>mergeConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeConcat() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.push(function customizer(a, b) {
    if ((0, _isPlainObject2.default)(a)) {
      return (0, _assignWith2.default)(a, b, customizer);
    } else if ((0, _isArray2.default)(a)) {
      return a.concat(b);
    } else {
      return b;
    }
  });
  return _assignWith2.default.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bodybuilder.utils.sortMerge" id="apidoc.element.bodybuilder.utils.sortMerge">
        function <span class="apidocSignatureSpan">bodybuilder.utils.</span>sortMerge
        <span class="apidocSignatureSpan">(current, field, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortMerge(current, field, value) {
  var payload = void 0;

  if ((0, _isPlainObject2.default)(value)) {
    payload = _defineProperty({}, field, (0, _assign2.default)({}, value));
  } else {
    payload = _defineProperty({}, field, { order: value });
  }

  var idx = (0, _findIndex2.default)(current, function (o) {
    return o[field] != undefined;
  });

  if (idx == -1) {
    current.push(payload);
  } else {
    (0, _extend2.default)(current[idx], payload);
  }

  return current;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
