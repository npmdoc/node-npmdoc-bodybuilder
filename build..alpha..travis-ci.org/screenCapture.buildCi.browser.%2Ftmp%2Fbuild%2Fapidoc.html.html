<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/danpaz/bodybuilder#readme">bodybuilder (v2.1.0)</a>
</h1>
<h4>An elasticsearch query body builder.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder">module bodybuilder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.bodybuilder">
            function <span class="apidocSignatureSpan"></span>bodybuilder
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>aggregation_builder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>bool_query</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>filter_builder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>query_builder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bodybuilder.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.aggregation_builder">module bodybuilder.aggregation_builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.aggregation_builder.default">
            function <span class="apidocSignatureSpan">bodybuilder.aggregation_builder.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.bool_query">module bodybuilder.bool_query</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.bool_query.default">
            function <span class="apidocSignatureSpan">bodybuilder.bool_query.</span>default
            <span class="apidocSignatureSpan">(condition, query)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.filter_builder">module bodybuilder.filter_builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.filter_builder.default">
            function <span class="apidocSignatureSpan">bodybuilder.filter_builder.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.query_builder">module bodybuilder.query_builder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.query_builder.default">
            function <span class="apidocSignatureSpan">bodybuilder.query_builder.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bodybuilder.utils">module bodybuilder.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.utils.boolMerge">
            function <span class="apidocSignatureSpan">bodybuilder.utils.</span>boolMerge
            <span class="apidocSignatureSpan">(newObj, currentObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.utils.buildClause">
            function <span class="apidocSignatureSpan">bodybuilder.utils.</span>buildClause
            <span class="apidocSignatureSpan">(field, value, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.utils.mergeConcat">
            function <span class="apidocSignatureSpan">bodybuilder.utils.</span>mergeConcat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bodybuilder.utils.sortMerge">
            function <span class="apidocSignatureSpan">bodybuilder.utils.</span>sortMerge
            <span class="apidocSignatureSpan">(current, field, value)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder" id="apidoc.module.bodybuilder">module bodybuilder</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.bodybuilder" id="apidoc.element.bodybuilder.bodybuilder">
        function <span class="apidocSignatureSpan"></span>bodybuilder
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bodybuilder() {
  var body = {};

  return Object.assign({
<span class="apidocCodeCommentSpan">    /**
     * Set a sort direction on a given field.
     *
     * @param  {String} field             Field name.
     * @param  {String} [direction='asc'] A valid direction: 'asc' or 'desc'.
     * @returns {bodybuilder} Builder.
     */
</span>    sort: function sort(field) {
      var direction = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 'asc';

      body.sort = body.sort || [];

      if ((0, _isArray2.default)(field)) {

        if ((0, _isPlainObject2.default)(body.sort)) {
          body.sort = [body.sort];
        }

        if ((0, _isArray2.default)(body.sort)) {
          (0, _each2.default)(field, function (sorts) {
            (0, _each2.default)(sorts, function (value, key) {
              (0, _utils.sortMerge)(body.sort, key, value);
            });
          });
        }
      } else {
        (0, _utils.sortMerge)(body.sort, field, direction);
      }
      return this;
    },


    /**
     * Set a *from* offset value, for paginating a query.
     *
     * @param  {Number} quantity The offset from the first result you want to
     *                           fetch.
     * @returns {bodybuilder} Builder.
     */
    from: function from(quantity) {
      body.from = quantity;
      return this;
    },


    /**
     * Set a *size* value for maximum results to return.
     *
     * @param  {Number} quantity Maximum number of results to return.
     * @returns {bodybuilder} Builder.
     */
    size: function size(quantity) {
      body.size = quantity;
      return this;
    },


    /**
     * Set any key-value on the elasticsearch body.
     *
     * @param  {String} k Key.
     * @param  {any}    v Value.
     * @returns {bodybuilder} Builder.
     */
    rawOption: function rawOption(k, v) {
      body[k] = v;
      return this;
    },


    /**
     * Collect all queries, filters, and aggregations and build the entire
     * elasticsearch query.
     *
     * @param  {string} [version] (optional) Pass `'v1'` to build for the
     *                            elasticsearch 1.x query dsl.
     *
     * @return {Object} Elasticsearch query body.
     */
    build: function build(version) {
      var queries = this.getQuery();
      var filters = this.getFilter();
      var aggregations = this.getAggregations();

      if (version === 'v1') {
        return _buildV1(body, queries, filters, aggregations);
      }

      return _build(body, queries, filters, aggregations);
    }
  }, (0, _queryBuilder2.default)(), (0, _filterBuilder2.default)(), (0, _aggregationBuilder2.default)());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.aggregation_builder" id="apidoc.module.bodybuilder.aggregation_builder">module bodybuilder.aggregation_builder</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.aggregation_builder.default" id="apidoc.element.bodybuilder.aggregation_builder.default">
        function <span class="apidocSignatureSpan">bodybuilder.aggregation_builder.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function aggregationBuilder() {
  var aggregations = {};

  function makeAggregation(type, field) {
    for (var _len = arguments.length, args = Array(_len &gt; 2 ? _len - 2 : 0), _key = 2; _key &lt; _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    var aggName = (0, _find2.default)(args, _isString2.default) || 'agg_' + type + '_' + field;
    var opts = (0, _find2.default)(args, _isPlainObject2.default);
    var nested = (0, _find2.default)(args, _isFunction2.default);
    var nestedClause = {};

    if ((0, _isFunction2.default)(nested)) {
      var nestedResult = nested(Object.assign({}, aggregationBuilder(), (0, _filterBuilder2.default)()));
      if (nestedResult.hasFilter()) {
        nestedClause.filter = nestedResult.getFilter();
      }
      if (nestedResult.hasAggregations()) {
        nestedClause.aggs = nestedResult.getAggregations();
      }
    }

    var innerClause = Object.assign({}, _defineProperty({}, type, (0, _utils.buildClause)(field, null, opts)), nestedClause);

    Object.assign(aggregations, _defineProperty({}, aggName, innerClause));
  }

  return {
<span class="apidocCodeCommentSpan">    /**
     * Add an aggregation clause to the query body.
     *
     * @param  {string|Object} type      Name of the aggregation type, such as
     *                                   `'sum'` or `'terms'`.
     * @param  {string}        field     Name of the field to aggregate over.
     * @param  {Object}        [options] (optional) Additional options to
     *                                   include in the aggregation.
     * @param  {string}        [name]    (optional) A custom name for the
     *                                   aggregation, defaults to
     *                                   `agg_&lt;type&gt;_&lt;field&gt;`.
     * @param  {Function}      [nest]    (optional) A function used to define
     *                                   sub-aggregations as children. This
     *                                   _must_ be the last argument.
     *
     * @return {bodybuilder} Builder.
     *
     * @example
     * bodybuilder()
     *   .aggregation('max', 'price')
     *   .build()
     *
     * bodybuilder()
     *   .aggregation('percentiles', 'load_time', {
     *     percents: [95, 99, 99.9]
     *   })
     *   .build()
     *
     * bodybuilder()
     *   .aggregation('date_range', 'date', {
     *     format: 'MM-yyy',
     *     ranges: [{ to: 'now-10M/M' }, { from: 'now-10M/M' }]
     *   })
     *   .build()
     *
     * bodybuilder()
     *   .aggregation('diversified_sampler', 'user.id', { shard_size: 200 }, (a) =&gt; {
     *     return a.aggregation('significant_terms', 'text', 'keywords')
     *   })
     *   .build()
     */
</span>    aggregation: function aggregation() {
      makeAggregation.apply(undefined, arguments);
      return this;
    },


    /**
     * Alias for `aggregation`.
     *
     * @return {bodybuilder} Builder.
     */
    agg: function agg() {
      return this.aggregation.apply(this, arguments);
    },
    getAggregations: function getAggregations() {
      return aggregations;
    },
    hasAggregations: function hasAggregations() {
      return !!(0, _size2.default)(aggregations);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.bool_query" id="apidoc.module.bodybuilder.bool_query">module bodybuilder.bool_query</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.bool_query.default" id="apidoc.element.bodybuilder.bool_query.default">
        function <span class="apidocSignatureSpan">bodybuilder.bool_query.</span>default
        <span class="apidocSignatureSpan">(condition, query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function boolQuery(condition, query) {
  var cond = CONDITIONS_MAP[condition];
  return {
    bool: _defineProperty({}, cond, [query])
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.filter_builder" id="apidoc.module.bodybuilder.filter_builder">module bodybuilder.filter_builder</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.filter_builder.default" id="apidoc.element.bodybuilder.filter_builder.default">
        function <span class="apidocSignatureSpan">bodybuilder.filter_builder.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterBuilder() {
  var filter = {};

  function addMinimumShouldMatch(str) {
    var shouldClause = (0, _get2.default)(filter, 'bool.should');
    if (shouldClause &amp;&amp; shouldClause.length &gt; 1) {
      filter.bool['minimum_should_match'] = str;
    }
  }

  function makeFilter(boolType, filterType) {
    var nested = {};

    for (var _len = arguments.length, args = Array(_len &gt; 2 ? _len - 2 : 0), _key = 2; _key &lt; _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if ((0, _isFunction2.default)((0, _last2.default)(args))) {
      var nestedCallback = args.pop();
      var nestedResult = nestedCallback(Object.assign({}, (0, _queryBuilder2.default)(), filterBuilder(), (0, _aggregationBuilder2
.default)()));
      if (nestedResult.hasQuery()) {
        nested.query = nestedResult.getQuery();
      }
      if (nestedResult.hasFilter()) {
        nested.filter = nestedResult.getFilter();
      }
      if (nestedResult.hasAggregations()) {
        nested.aggs = nestedResult.getAggregations();
      }
    }

    filter = (0, _utils.boolMerge)(_defineProperty({}, filterType, Object.assign(_utils.buildClause.apply(undefined, args), nested
)), filter, boolType);
  }

  return {
<span class="apidocCodeCommentSpan">    /**
     * Add a filter clause to the query body.
     *
     * @param  {string}        type    Filter type.
     * @param  {string|Object} field   Field to filter or complete filter
     *                                 clause.
     * @param  {string|Object} value   Filter term or inner clause.
     * @param  {Object}        options (optional) Additional options for the
     *                                 filter clause.
     * @param  {Function}      [nest]  (optional) A function used to define
     *                                 sub-filters as children. This _must_ be
     *                                 the last argument.
     *
     * @return {bodybuilder} Builder.
     *
     * @example
     * bodybuilder()
     *   .filter('term', 'user', 'kimchy')
     *   .build()
     */
</span>    filter: function filter() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 &lt; _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      makeFilter.apply(undefined, ['and'].concat(args));
      return this;
    },


    /**
     * Alias for `filter`.
     *
     * @return {bodybuilder} Builder.
     */
    andFilter: function andFilter() {
      return this.filter.apply(this, arguments);
    },


    /**
     * Alias for `filter`.
     *
     * @return {bodybuilder} Builder.
     */
    addFilter: function addFilter() {
      return this.filter.apply(this, arguments);
    },


    /**
     * Add a "should" filter to the query body.
     *
     * Same arguments as `filter`.
     *
     * @return {bodybuilder} Builder.
     */
    orFilter: function orFilter() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 &lt; _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      makeFilter.apply(undefined, ['or'].concat(args));
      return this;
    },


    /**
     * Add a "must_not" filter to the query body.
     *
     * Same arguments as `filter`.
     *
     * @return {bodybuilder} Builder.
     */
    notFilter: function notFilter() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 &lt; _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      makeFilter.apply(undefined, ['not'].concat(args));
      return this;
    },


    /**
     * Set the `minimum_should_match` property on a bool filter with more than
     * one `should` clause.
     *
     * @param  {any} param  minimum_should_match parameter. For possible values
     *                      see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-minimum-should-match.html
     * @return {bodybuilder} Builder.
     */
    filterMinimumShouldMatch: function filterMinimumShouldMatch(param) {
      addMinimumShouldMatch(param);
      return this;
    },
    getFilter: function getFilter() {
      return filter;
    },
    hasFilter: function h ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.query_builder" id="apidoc.module.bodybuilder.query_builder">module bodybuilder.query_builder</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.query_builder.default" id="apidoc.element.bodybuilder.query_builder.default">
        function <span class="apidocSignatureSpan">bodybuilder.query_builder.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queryBuilder() {
  var query = {};

  function addMinimumShouldMatch(str) {
    var shouldClause = (0, _get2.default)(query, 'bool.should');
    if (shouldClause &amp;&amp; shouldClause.length &gt; 1) {
      query.bool['minimum_should_match'] = str;
    }
  }

  function makeQuery(boolType, queryType) {
    var nested = {};

    for (var _len = arguments.length, args = Array(_len &gt; 2 ? _len - 2 : 0), _key = 2; _key &lt; _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if ((0, _isFunction2.default)((0, _last2.default)(args))) {
      var nestedCallback = args.pop();
      var nestedResult = nestedCallback(Object.assign({}, queryBuilder(), (0, _filterBuilder2.default)()));
      if (nestedResult.hasQuery()) {
        nested.query = nestedResult.getQuery();
      }
      if (nestedResult.hasFilter()) {
        nested.filter = nestedResult.getFilter();
      }
    }

    query = (0, _utils.boolMerge)(_defineProperty({}, queryType, Object.assign(_utils.buildClause.apply(undefined, args), nested
)), query, boolType);
  }

  return {
<span class="apidocCodeCommentSpan">    /**
     * Add a query clause to the query body.
     *
     * @param  {string}        type    Query type.
     * @param  {string|Object} field   Field to query or complete query clause.
     * @param  {string|Object} value   Query term or inner clause.
     * @param  {Object}        options (optional) Additional options for the
     *                                 query clause.
     * @param  {Function}      [nest]  (optional) A function used to define
     *                                 sub-filters as children. This _must_ be
     *                                 the last argument.
     *
     * @return {bodybuilder} Builder.
     *
     * @example
     * bodybuilder()
     *   .query('match_all')
     *   .build()
     *
     * bodybuilder()
     *   .query('match_all', { boost: 1.2 })
     *   .build()
     *
     * bodybuilder()
     *   .query('match', 'message', 'this is a test')
     *   .build()
     *
     * bodybuilder()
     *   .query('terms', 'user', ['kimchy', 'elastic'])
     *   .build()
     *
     * bodybuilder()
     *   .query('nested', { path: 'obj1', score_mode: 'avg' }, (q) =&gt; {
     *     return q
     *       .query('match', 'obj1.name', 'blue')
     *       .query('range', 'obj1.count', {gt: 5})
     *   })
     *   .build()
     */
</span>    query: function query() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 &lt; _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      makeQuery.apply(undefined, ['and'].concat(args));
      return this;
    },


    /**
     * Alias for `query`.
     *
     * @return {bodybuilder} Builder.
     */
    andQuery: function andQuery() {
      return this.query.apply(this, arguments);
    },


    /**
     * Alias for `query`.
     *
     * @return {bodybuilder} Builder.
     */
    addQuery: function addQuery() {
      return this.query.apply(this, arguments);
    },


    /**
     * Add a "should" query to the query body.
     *
     * Same arguments as `query`.
     *
     * @return {bodybuilder} Builder.
     */
    orQuery: function orQuery() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 &lt; _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      makeQuery.apply(undefined, ['or'].concat(args));
      return this;
    },


    /**
     * Add a "must_not" query to the query body.
     *
     * Same arguments as `query`.
     *
     * @return {bodybuilder} Builder.
     */
    notQuery: function notQuery() {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 &lt; _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      makeQuery.apply(undefined, ['not'].concat(args));
      return this;
    },


    /**
     * Set the `minimum_should_match` property on a bool query with more than
     * one `should` clause.
     *
     * @param  {any} param  minimum_should_match parameter. For possible values
     *                      see https://www.elastic.co/guide/en/elasticsearch/reference/curre ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bodybuilder.utils" id="apidoc.module.bodybuilder.utils">module bodybuilder.utils</a></h1>


    <h2>
        <a href="#apidoc.element.bodybuilder.utils.boolMerge" id="apidoc.element.bodybuilder.utils.boolMerge">
        function <span class="apidocSignatureSpan">bodybuilder.utils.</span>boolMerge
        <span class="apidocSignatureSpan">(newObj, currentObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function boolMerge(newObj, currentObj) {
  var boolType = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : 'and';

  var boolCurrent = void 0;
  var boolNew = void 0;

  // Only one, no need for bool.
  if ((0, _isEmpty2.default)(currentObj)) {
    // Allow starting with 'or' and 'not' queries.
    if (boolType !== 'and') {
      return (0, _boolQuery2.default)(boolType, newObj);
    }
    return newObj;
  }

  // Make bools out of the new and existing filters.
  boolCurrent = currentObj.bool ? currentObj : (0, _boolQuery2.default)('must', currentObj);
  boolNew = newObj.bool ? newObj : (0, _boolQuery2.default)(boolType, newObj);

  return mergeConcat({}, boolCurrent, boolNew);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bodybuilder.utils.buildClause" id="apidoc.element.bodybuilder.utils.buildClause">
        function <span class="apidocSignatureSpan">bodybuilder.utils.</span>buildClause
        <span class="apidocSignatureSpan">(field, value, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buildClause(field, value, opts) {
  var hasField = !(0, _isNil2.default)(field);
  var hasValue = !(0, _isNil2.default)(value);
  var mainClause = {};

  if (hasValue) {
    mainClause = _defineProperty({}, field, value);
  } else if ((0, _isObject2.default)(field)) {
    mainClause = field;
  } else if (hasField) {
    mainClause = { field: field };
  }

  return Object.assign({}, mainClause, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bodybuilder.utils.mergeConcat" id="apidoc.element.bodybuilder.utils.mergeConcat">
        function <span class="apidocSignatureSpan">bodybuilder.utils.</span>mergeConcat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeConcat() {
  var args = Array.prototype.slice.call(arguments, 0);
  args.push(function customizer(a, b) {
    if ((0, _isPlainObject2.default)(a)) {
      return (0, _assignWith2.default)(a, b, customizer);
    } else if ((0, _isArray2.default)(a)) {
      return a.concat(b);
    } else {
      return b;
    }
  });
  return _assignWith2.default.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bodybuilder.utils.sortMerge" id="apidoc.element.bodybuilder.utils.sortMerge">
        function <span class="apidocSignatureSpan">bodybuilder.utils.</span>sortMerge
        <span class="apidocSignatureSpan">(current, field, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortMerge(current, field, value) {
  var payload = void 0;

  if ((0, _isPlainObject2.default)(value)) {
    payload = _defineProperty({}, field, (0, _assign2.default)({}, value));
  } else {
    payload = _defineProperty({}, field, { order: value });
  }

  var idx = (0, _findIndex2.default)(current, function (o) {
    return o[field] != undefined;
  });

  if (idx == -1) {
    current.push(payload);
  } else {
    (0, _extend2.default)(current[idx], payload);
  }

  return current;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>